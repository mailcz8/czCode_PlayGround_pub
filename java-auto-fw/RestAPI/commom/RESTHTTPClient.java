package commom;import java.io.File;import java.io.IOException;import java.io.InputStream;import org.apache.http.Header;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.ParseException;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.ByteArrayEntity;import org.apache.http.entity.ContentType;import org.apache.http.entity.mime.HttpMultipartMode;import org.apache.http.entity.mime.MultipartEntityBuilder;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import baseHelper.ExecutionLog;public class RESTHTTPClient {	private String endPointURL = null;	private String encoding = null;	private String request = null;	private String contentFile = null;	private File file = null;	private static final CloseableHttpClient CLIENT = HttpClients.createDefault();	private HttpResponse response;	public RESTHTTPClient(String url, String reqEncoding, String reqXML) {		endPointURL = url;		encoding = reqEncoding;		request = reqXML;	}	public boolean setContentFile(String reqContentFile) {		boolean setFile = false;		file = new File(reqContentFile);		if (file.exists()) {			contentFile = reqContentFile;			setFile = true;		} else {			setFile = false;		}		return setFile;	}	public boolean executeApplicationXML(String reqContentType) {		HttpEntity entity;		try {			entity = new ByteArrayEntity(request.getBytes(encoding));			HttpPost httpPost = new HttpPost(endPointURL);			httpPost.setHeader("Content-type", reqContentType);			httpPost.setEntity(entity);			response = CLIENT.execute(httpPost);			return true;		} catch (IOException e) {			System.out.println("Exception occured. Exception: " + e.getMessage());			e.printStackTrace();			return false;		}	}	public boolean executeMultiPartFormDataXMLFile(ContentType requestContentType, ContentType fileContentType) {		boolean isExecuted = false;		if (contentFile != null) {			if (requestContentType != null && fileContentType != null) {				try {					HttpPost httpPost = new HttpPost(endPointURL);					MultipartEntityBuilder builder = MultipartEntityBuilder.create();					builder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE);					builder.addBinaryBody("Content", file, fileContentType, contentFile);					builder.addTextBody("Request", request, requestContentType);					HttpEntity multipartEntity = builder.build();					httpPost.setEntity(multipartEntity);					response = CLIENT.execute(httpPost);					isExecuted = true;				} catch (Exception e) {					ExecutionLog.Log("EXCEPTION:  " + e.getMessage());					isExecuted = false;				}			} else {				ExecutionLog.Log("ERROR:  Invalid request content type \"" + requestContentType						+ "\" or content content type \"" + fileContentType + "\"");				isExecuted = false;			}		} else {			ExecutionLog.Log("ERROR:  File \"" + contentFile + "\""					+ "not set properly. Try setContentFile before calling this method.");			isExecuted = false;		}		return isExecuted;	}	/*	 * executeMultiPartFormDataWithSmallXml	 * 	 * @author Sanjay Sharma	 */	public boolean executeMultiPartFormDataWithSmallXml(InputStream contentParamValue,			ContentType contentParamMimeType) {		try {			HttpPost httpPost = new HttpPost(endPointURL);			MultipartEntityBuilder builder = MultipartEntityBuilder.create();			builder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE);			builder.addBinaryBody("content", contentParamValue, contentParamMimeType, "updateDims.xml");			// builder.addBinaryBody("content", contentParamValue,			// contentParamMimeType, "updateDims.zip"); //ZIP will also work but			// we need to update Input Stream accordingly.			builder.addTextBody("request", request, ContentType.TEXT_XML);			HttpEntity multipartEntity = builder.build();			httpPost.setEntity(multipartEntity);			response = CLIENT.execute(httpPost);			return true;		} catch (Exception e) {			ExecutionLog.Log("EXCEPTION:  " + e.getMessage());			return false;		}	}	public boolean executeMultiPartMixedDataXMLFile() {		boolean isExecuted = false;		if (contentFile != null) {			try {				HttpPost httpPost = new HttpPost(endPointURL);				MultipartEntityBuilder builder = MultipartEntityBuilder.create();				builder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE);				HttpEntity multipartEntity = builder.build();				httpPost.setEntity(multipartEntity);				httpPost.addHeader("Content-Type", "multipart/mixed");				response = CLIENT.execute(httpPost);				isExecuted = true;			} catch (Exception e) {				ExecutionLog.Log("EXCEPTION:  " + e.getMessage());				isExecuted = false;			}		} else {			ExecutionLog.Log("ERROR:  File \"" + contentFile + "\""					+ "not set properly. Try setContentFile before calling this method.");			isExecuted = false;		}		return isExecuted;	}	public String getResponseXML() throws ParseException, IOException {		String result = EntityUtils.toString(response.getEntity());		return result;	}	public int getResponseStatusCode() throws IOException {		if (response != null) {			return response.getStatusLine().getStatusCode();		}		return 0;	}	public Header getResponseContentType() {		return response.getEntity().getContentType();	}	public void printAllResponseHeaders() {		Header[] headers = response.getAllHeaders();		System.out.println("Response Headers:");		for (Header header : headers) {			System.out.println("	" + header.getName() + ":" + header.getValue());		}	}	public void closeClient() throws IOException {		CLIENT.close();	}}